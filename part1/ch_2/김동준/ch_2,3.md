# 람다 이모저모

## 1. 기본 문법

### (1) 함수형 인터페이스

람다식은 함수형 인터페이스(`@FunctionalInterface`)를 구현하는 것으로부터 시작됨. 이 함수형 인터페이스의 특징은 **무조건 추상 메소드를 하나만 가질 것**이다. 자바 API가 기본적으로 제공하는 함수형 인터페이스들(`Predicate`, `Comparator`, `Runnable`, `Callable`) 외에도 개발자가 커스텀하게 함수형 인터페이스 선언이 가능

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int x, int y);
}
```
```java
public class Main {
    public static void main(String[] args) {
        Calculator plus = (x, y) -> x + y;
        Calculator minus = (x, y) -> x - y;
        Calculator multiple = (x, y) -> x * y;
        Calculator divide = (x, y) -> x / y;

        System.out.println(plus.calculate(6, 2));
        System.out.println(minus.calculate(6, 2));
        System.out.println(multiple.calculate(6, 2));
        System.out.println(divide.calculate(6, 2));
    }
}
```

아래처럼 람다식의 형태가 동일해도 상위 함수형 인터페이스가 다른 경우가 있을 수도 있다.

```java
import java.util.function.Function;
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        Predicate<String> predicate = str -> str.length() > 5;
        Function<String, Boolean> function = str -> str.length() > 5;

        System.out.println(predicate.test("abcdef")); // true
        System.out.println(function.apply("abcdef")); // true
    }
}
```

람다식 그 자체로는 구현의 기반이 된 함수형 인터페이스가 어떤 것인지 타입을 확인하기 어렵다. 자바 컴파일러는 아래와 같은 정보들을 바탕으로 타입을 추론한다. 위처럼 람다식이 할당된 변수의 타입을 통해 컴파일러가 타입을 추론하게 된다.
> 1. 람다식이 할당된 변수의 타입
> 2. 람다식을 인자로 받는 메서드의 매개변수 타입
> 3. 람다식이 사용된 컨텍스트(타입을 요구하는 상황)

즉 위와 같은 정보들이 없으면 컴파일러는 람다식의 타입을 추론할 수 없게 되므로 컴파일 에러를 일으키게 된다.

<img width="80%" alt="스크린샷 2025-02-16 오후 7 14 15" src="https://github.com/user-attachments/assets/6a76e88d-4e09-459e-a8fe-083c7bdefea9" />

### (2) 클로저(Closure)

**변수 캡처**는 람다식이나 익명 클래스가 외부 변수의 값을 사용할 때 발생하는 현상으로, 람다식 내부에서 외부 변수에 접근하는 방식.\
**클로저**는 람다식이나 익명 클래스가 외부 변수의 값을 캡처하고 그 변수를 계속 유지하는 성질.
