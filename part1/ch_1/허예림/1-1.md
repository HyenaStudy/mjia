### 1.2 자바 설계 밑바탕1 : 스트림

- 스트림 처리란 데이터를 한 번에 한 개씩 순차적으로 처리하는 방식이다.
- 스트림은 일반적으로 입력 스트림과 출력 스트림으로 구분되며, 입력 스트림에서 데이터를 받아들여 변환한 후, 출력 스트림으로 데이터를 전달할 수 있다.
   
### 자바 8의 스트림 API

- 자바 8에서는 java.util.stream 패키지에 스트림 API가 추가되었다.
- 기존에는 데이터를 한 번에 처리했다면, 스트림 API를 사용하면 데이터를 조립 라인처럼 한 개씩 순차적으로 처리할 수 있다.

**예제**

```java
List<String> words = Arrays.asList("Apple", "Banana", "Cherry");
List<String> result = words.stream()
                           .map(String::toLowerCase)
                           .sorted()                 
                           .collect(Collectors.toList()); 

```
**장점**
- 고속 데이터 처리
- 파이프라인 처리
병렬 처리(공짜 병렬성)

-> 자바 8 이후의 프로그램에서는 반복문보다 스트림 API를 활용하는 것이 더욱 직관적이며 효율적인 데이터 처리 방법이 될 수 있다.

### 동작 파라미터화로 메서드에 코드 전달하기

**개념**
자바 8에서는 코드 일부를 API의 인자로 전달하는 기능이 추가되었다.


**예제: 송장 ID 정렬**
- `2013UK0001`, `2014US0002`

송장 ID의 구성 요소:

1. 처음 네 자리 숫자 → 연도
2. 다음 두 글자 → 국가 코드
3. 마지막 네 자리 숫자 → 고객 ID

기존 방식으로는 sort를 사용할 경우 정렬 기준이 고정되므로, ID나 국가 코드 기준으로 정렬하려면 별도의 코드가 필요

**자바 8 이전의 방식: Comparator 사용**

자바 8 이전에는 정렬 기준을 변경하려면 `Comparator` 객체를 만들어 `sort`에 전달해야 했다.
->매번 새로운 Comparator 객체를 생성해야 하므로 코드가 복잡하고 유지보수가 어렵다

```java
public int compareUsingCustomerId(String inv1, String inv2) {
    return extractCustomerId(inv1).compareTo(extractCustomerId(inv2));
}

```
**자바 8 이후: 동작 파라미터화 적용**
compareUsingCustomerId 메서드를 sort의 인자로 전달하여 정렬 기준을 동적으로 지정 가능

```java
List<String> invoices = Arrays.asList("2013UK0001", "2014US0002");

// 고객 ID 기준 정렬
invoices.sort(this::compareUsingCustomerId);

```

- 스트림 API에서도 연산의 동작을 파라미터화하여 코드에 동적으로 전달하는 방식이 적용된다.
- sort뿐만 아니라 filter, map, reduce 같은 다양한 연산에서 활용된다.
- 코드 재사용성을 높이고, 불필요한 중복을 줄이며, 유연한 프로그램을 작성할 수 있게 해준다.

### 병렬성과 공유 가변 데이터

**안전한 병렬 실행**

다른 코드와 동시에 실행되더라도 공유된 가변 데이터에 접근하지 않아야 한다.

- **순수 함수(pure function)** : 부작용이 없는 함수
- **상태 없는 함수(stateless function)** : 외부 상태를 변경하지 않는 함수

이러한 원칙을 따르면 병렬 실행이 가능해지고, 코드의 예측 가능성이 높아진다.

---

### **공유된 가변 데이터와 병렬성 문제**

병렬 환경에서는 공유된 가변 변수가 있을 경우 문제가 발생한다.
이 문제를 해결하는 방법 중 하나로, synchronized를 사용하여 공유된 데이터를 보호할 수 있다.
하지만 synchronized는 시스템 성능을 저하시킬 가능성이 크다.
자바 8에서는 스트림 API를 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다.

---

### **병렬 스트림과 성능 문제**

자바 8에서는 parallel stream을 통해 다중 코어 환경에서 효율적으로 작업을 수행할 수 있다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.parallelStream().reduce(0, Integer::sum);

```


### **함수형 프로그래밍과 병렬성**
**함수형 프로그래밍의 개념**
- 공유되지 않는 가변 데이터
- 메서드와 함수 코드를 다른 메서드로 전달하는 구조

**명령형 프로그래밍(imperative programming)**
- 상태를 유지하면서 연산을 수행하기 때문에 공유된 변수가 있을 경우 병렬성 문제를 해결하기 어렵다.

## Chapter2 동작 파라미터화 코드 전달하기

### 동작 파라미터화란?

**개념**

동작 파라미터화(Action Parameterization)란 메서드의 동작을 매개변수로 전달하여 실행 시점에 원하는 로직을 적용할 수 있도록 하는 기법이다. 
대표적으로 함수형 프로그래밍에서 자주 활용되며, 자바에서는 Comparator, Predicate, Function 등의 함수형 인터페이스를 사용하여 구현할 수 있다.


**장점**

- 코드 재사용성을 높일 수 있다.
- 동작을 분리하여 코드의 가독성을 향상시킬 수 있다.
- 불필요한 중복 코드를 줄일 수 있다.
- 실행 시점에 다양한 로직을 적용할 수 있어 유연성이 증가한다.
- 람다 표현식과 함께 사용하면 간결한 코드 작성이 가능하다.
- 새로운 기능을 쉽게 추가할 수 있으며, 유지보수가 용이해진다.

예를 들어, 농부의 요구사항을 반영하여 녹색 사과를 찾는 메서드를 작성했다고 가정하자. 하지만 이후 빨간 사과를 찾는 메서드가 필요해진다면, 기존 메서드를 복사하여 조건만 변경하는 방식은 비효율적이다. 이런 문제를 해결하기 위해, 색을 파라미터화하여 filterApplesByColor(List<Apple> inventory, Color color)와 같은 형태로 변경하면 코드의 중복을 줄이고 유지보수를 용이하게 할 수 있다.

하지만 이렇게 색상만을 고려하는 방식에도 한계가 있다. 농부가 "색상뿐만 아니라 무게도 고려해서 필터링해 주세요."라고 요청할 경우, 단순히 filterApplesByColor를 확장하는 방식으로는 충분하지 않다. 이를 해결하기 위해, **동작을 일반화하여 모든 필터링 조건을 하나의 메서드에서 처리할 수 있도록** 만들어야 한다.

---

**단점**

- 코드의 흐름을 한눈에 이해하기 어려울 수 있다.
- 유지보수가 어려워질 수 있다. (특히, 과도하게 사용하면 가독성이 떨어질 위험이 있음)
- 디버깅이 어려울 수 있다. (익명 함수나 람다 표현식을 활용할 경우 스택 트레이스 분석이 복잡해질 수 있음)
- 초기에 설계할 때 적절한 인터페이스나 추상화를 고민해야 하므로 설계 부담이 증가할 수 있다.

특히, 동작 파라미터화를 무분별하게 사용하면 코드가 지나치게 복잡해질 수 있다. 예를 들어, 사과를 필터링할 때 색상뿐만 아니라 무게까지 고려해야 한다면, filterApplesByColor와 filterApplesByWeight를 따로 구현할 수도 있지만, 이러한 방식은 계속해서 새로운 메서드를 추가해야 하는 문제가 있다.

### 잘못된 동작 파라미터화 사례

잘못된 동작 파라미터화의 예로, 모든 필터링 조건을 하나의 메서드에서 처리하려는 시도를 생각해 볼 수 있다.

```java
public static List<Apple> filterApples(List<Apple> inventory, Color color, int weight, boolean flag) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if ((flag && apple.getColor().equals(color)) || (!flag && apple.getWeight() > weight)) {
            result.add(apple);
        }
    }
    return result;
}

```

위 코드에서 flag 값이 true이면 색상으로 필터링하고, false이면 무게로 필터링하는 구조이다. 하지만 이런 방식은 다음과 같은 문제를 발생시킨다.

- true와 false가 의미하는 바가 불분명하여 코드의 가독성이 떨어진다.
- 앞으로 요구사항이 변경되면 추가적인 파라미터가 계속 늘어날 가능성이 있다.
- 예를 들어, "사과의 크기"나 "출하 지역" 등을 기준으로 필터링하려면 새로운 메서드나 더 많은 조건이 필요하게 된다.

이러한 방식은 결국 필터링 조건이 많아질수록 거대한 메서드가 만들어지고 유지보수가 어려워지는 결과를 초래한다. 따라서 올바른 방법은 필터링 조건 자체를 동적으로 전달하는 방식을 사용하는 것이다.

---

**목적**

- 코드의 유연성을 높여 재사용성을 극대화하기 위함
- 특정 조건이나 동작을 실행 시점에 결정할 수 있도록 하기 위함
- 중복 코드를 줄이고 가독성을 향상시키기 위함
- 함수형 프로그래밍 스타일을 적용하여 간결한 코드 작성을 유도하기 위함
- 변경이 잦은 요구사항에도 쉽게 대응할 수 있도록 하기 위함

실제로, 자바 8의 **람다 표현식**을 활용하면 동작 파라미터화를 더욱 간결하게 구현할 수 있다. 예를 들어,

```java
List<Apple> greenApples = filterApples(inventory, apple -> apple.getColor().equals(GREEN));
List<Apple> heavyApples = filterApples(inventory, apple -> apple.getWeight() > 150);

```

이처럼 동작을 파라미터화하면 코드의 유연성과 가독성이 높아지고, 새로운 조건을 추가할 때도 기존 메서드를 변경하지 않아도 된다