### 7.1

**순차 스트림**

- 한개의 스레드가 데이터를 순서대로 처리한다.
- 한 스레드의 연산이 완료될 때까지 대기해야 한다.

**병렬 스트림**

- 여러개의 스레드를 사용하여 데이터를 병렬로 처리한다.
- 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.
- 컨택스트 스위칭 비용을 고려해야 한다.
- 스트림 내 연산이 순서를 보장하지 않는다.

**병렬 스트림 처리 과정**

- Java의 ForkJoinPool을 사용하여 데이터를 여러 개의 서브 태스크로 나누고 병렬로 실행하는 구조를 가진다.
- Splitting : 병렬 스트림 내부에서 데이터를 작은 단위로 분할 하는 단계
    - Spliterator를 사용하여 데이터를 여러개의 블록으로 나눈다. (재귀 분할)
- Processing : 여러개의 스레드에서 데이터를 동시에 처리한다.
    - Fork와 Join과정을 수행한다.
- Combining : 여러개의 스레드에서 처리한 결과를 합친다
    - 추가적인 정렬이 필요한 연산의 경우 이때 정렬을 수행한다.

**병렬 스트림 최적화**

- 기본적으로 CPU 코어 개수에 맞게 스레드의 개수가 설정된다.
- 스레드 조절 방법 1 : Property 설정
    
    ```java
    System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "4");
    ```
    
    - 현재 실행되는 프로세스의 모든 ForkJoinPool의 commonPool에 설정되어 적용되며 JVM 전체에 영향을 미칠 수 있기 떄문에 사용 지양

- 스레드 조절 방법 2 : 직접 정이한 ForkJoinPool사용
    
    ```java
    ForkJoinPool forkJoinPool = new ForkJoinPool(6); 
    forkJoinPool.submit(() -> numbers.parallelStream()        
    				.forEach(number -> {            
    						try {                
    								Thread.sleep(3000);                
    								System.out.println(number + ": " + Thread.currentThread().getName());            
    						} catch (InterruptedException e) {}        
    				})).get();
    
    ```
    
- ForkJoinPool생성자에 스레드 개수를 지정하여 사용할 수 있으며 지정한 수만큼 스레드를 이용하여 처리한다.

### 7.1.1 순차 스트림 ↔ 병렬 스트림

- 순차 스트림 생성 후 parallel 메서드를 호출 시 병렬 연산 수행.
- 스트림 자체에 변화가 발생하는 것이 아닌 BooleanFlag 설정
- 마찬 가지로 병렬 스트림도 sequential 메서드를 통해 병렬 연산 가능

### 7.1.3 병렬 스트림의 동시성

- 병렬 스트림에서 공유 자원 (변수, 리스트, 맵)등 접근 시 경쟁 상태가 발생할 수 있다.
- 병렬 스트림은 특히 실행 순서를 보장하지 않기 때문에 충돌이 발생할 가능성이 높다

### 7.1.4 병렬 스트림 고려 사항

- 순차 스트림을 쉽게 병렬 스트림으로 변환할 수 있지만, 항상 병렬 스트림이 더 빠른 것은 아니다.
- 병렬 처리의 성능은 데이터의 특성과 실행 환경에 따라 달라지므로 신중하게 결정해야 한다.
1. **병렬 스트림 사용 시 고려할 점**
    - 기본형 데이터를 다룰 때는 IntStream, LongStream, DoubleStream과 같은 기본형 특화 스트림을 사용하는 것이 좋다. 이를 통해 불필요한 박싱과 언박싱을 줄여 성능을 향상시킬 수 있다.
    - 병렬 스트림이 항상 성능을 향상시키는 것은 아니며, 일부 연산에서는 오히려 순차 스트림이 더 효율적일 수도 있다
    - 병렬 스트림은 데이터를 여러 개의 쓰레드에서 나누어 처리하기 때문에, 데이터 소스가 이를 효율적으로 지원할 수 있어야 한다
        
### 7.2 포크 조인 프레임워크

- 큰 작업을 여러 개의 작은 서브태스크로 분할한 후 여러개의 스레드에서 병렬로 처리한 뒤, 결과를 합쳐 최종 결과를 도출하는 방식으로 동작하는 Java의 프레임워크
- work-Stealing 알고리즘을 사용하여 작업 부하를 동적으로 조절한다..

**RecursiveTask**

- 반환 값이 있는 병렬 작업 수행시 사용
- compute 메서드를 오버라이드 하여 작업 쪼개기 수행
- 작업 크기가 기준 이하면 직접 계산하고, 기준을 초과하면 fork를 호출하여 병렬 실행 후 join

**RecursiveAction**

- 반환 값이 없는 병렬 작업 수행시 사용

### 7.2.1 work-Stealing 알고리즘

- 멀티 코어 환경에서 스레드 간 작업 부하를 균등하게 분배하기 위한 알고리즘
- 하나의 스레드가 자신의 작업을 모두 수행한 후 다른 스레드의 남은 작업을 훔쳐와 처리
- 작업이 고르게 분배되어 전체 시스템을 효율적으로 운영할 수 있다.
- 각 스레드의 자신만의 작업 큐를 가지고 실행 후 자신의 큐가 비었을 때 다른 스레드의 큐에서 작업을 훔쳐 실행한다.
- 작업을 훔치는데 동기화 비용이 발생할 수 있다.

**Fork/Join Framework**

- ForkJoinPool이 여러개의 작업을 분할하고 각 스레드에 할당한다.
- 스레드가 자신의 큐에서 작업을 꺼내 실행한다.
- 스레드 큐가 비게 되면 다른 스레드의 큐에서 작업을 훔쳐와 실행한다.

### 7.2.2 Fork/Join 프레임워크의 주의점

**join 메서드 사용시 주의점**

- join 메서드는 결과가 될 때까지 호출을 블로킹 함
- 두개의 서브 태스크가 모두 시작된 후 join을 수행해야 병렬 실행의 이점을 유지할 수 있다.

**RecurisveTasj에서 invoke()사용 금지**

- invoke는 동기적으로 실행되며 호출한 스레드에서 직접 실행됨
- 반면 compute() 내부에서는 fork()를 사용하여 비동기적으로 작업을 병렬 실행
    

### 7.2.3 병렬 스트림과 포크조인프레임워크

**병렬 스트림**

- 컬렉션 데이터 처리 위주
- 내부적으로 ForkJoinPool 사용하여 자동 병렬화
- 대량의 컬렉션 데이터 처리 시 유리

**포크조인 프레임워크**

- 복잡한 병렬 계산 수행
- 개발자가 직접 작업을 나누고 합치는 방식
- 재귀적 분할에 유리

### **7.3 Spliterator 인터페이스 정리**

### **1. Spliterator 개요**

- 스트림의 요소를 효율적으로 분할하고 탐색하는 기능을 제공.
- 기본 iterator 유사하지만 데이터를 분할한다는 점에서 병렬 처리를 고려한 특화된 기능이 포함

### **2. Spliterator 주요 메서드**

**tryAdvance(Consumer<? super T> action)**

- 요소를 하나씩 순차적으로 가져와 처리
- 요소가 존재하면 true를 없으면 false를 반환
- 리스트에서 하나씩 출력할 떄 사용가능

**trySplit()**

- 데이터의 일부분을 분리하여 새로운 Spliterator 생성
- 데이터 크기가 너무 작으면 분할이 이루어지지 않음

**estimateSize()**

- Spliterator가 처리해야 할 남은 요소의 수를 예측하는 역할 수행
- 정확한 값이 아닐 수도 있지만, 병렬 처리에서 작업을 분배할 때 도움이 됨

**characteristics()**

- Spliterator가 관리하는 데이터의 특성을 나타내는 플래그 값을 반환

### **3. Spliterator의 분할 과정**

**trySplit**

- trySplit을 반복적으로 호출하면세 데이터를 여러개 구조의 Spliterator로 분할
- 특정 크기 이하가 되면 더 이상 분할하지 않고 탐색을 수행.

**characteristics**

- characteristics 메서드를 통해 정렬,, DISTINCT, 크기 예측(SIZED) 등의 속성 확인 가능.
