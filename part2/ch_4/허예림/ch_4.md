## 4.1 스트림 소개

**스트림**

- 컬렉션 데이터를 보다 효율적이고 선언적인 방식으로 처리할 수 있도록 합니다.
- 스트림을 활용하면 컬렉션의 요소들을 명확한 처리 파이프라인으로 연결하여 반복 작업을 수행할 수 있으며, 병렬 처리를 통한 성능 최적화도 가능합니다.

**스트림 병렬 처리와 성능 최적화**

- 병렬 처리 : 데이터를 여러개의 처리 단위로 분할하여 동시에 처리하는 것
    - 컬렉션의 각 요소를 순차적으로 처리하는 대신, 요소들을 여러 스레드에 분배해 동시에 작업을 수행하여 작업 속도를 개선
    - 스트림을 사용할 때 이런 병렬 처리는 내부적으로 여러 CPU 코어를 활용하여 작업을 분산 실행
- 데이터 분할 : 데이터 소스를 Spliterator를 사용해 여러 조각으로 분산, 데이터가 균등하게 분할 될 수 있도록 최적화하며 각 조각은 독립적으로 처리할 수 있는 단위가 됩니다.
- 병렬 조인 (Fork/Join 프레임워크) : 분할된 데이터 조각은 Java의 fork/join 프레임워크를 통해 각기 다른 스레드에서 동시에 처리됩니다. 각 스레드는 자신에게 할당된 데이터 청크에 대해 지정된 연산 (map, filter, reducee)를 수행합니다.
- 결과 병합 : 각 스레드에서 처리한 결과는 최종적으로 병합(collect, reduce 등)되어 하나의 결과로 만들어집니다. 이 병합 과정은 순차적으로 이루어지지만, 앞서 각 청크가 병렬로 처리된 덕분에 전체 처리 시간이 단축됩니다.
- 따라서 데이터 간의 독립성이 보장되어야 올바르게 적용할 수 있습니.

**고수준 빌딩 블록**

- filter, sorted, map, collect와 같은 스트림 API가 제공하는 메서드입니다. 내부적으로 반복, 조건 판단, 데이터 변환 등의 복잡한 로직을 감추고 개발자가 원하는 작업을 선언적으로 표현할 수 있도록 돕습니다.
- 특징 1 추상화 : 내부의 반복문이나 인덱스 관리 같은 세부 구현을 숨겨 무엇을 해야 하는지에 집중
- 특징 2 재사용성 : 각 연산은 독립적으로 설계되어, 여러 연산을 순서대로 연결(체이닝)할 수 있습니다.
- 특징 3 가독성 : 복잡한 로직도 각 단계별로 나눠서 작성할 수 있으므로, 코드의 의도가 명확해지고 유지보수가 쉬워집니다.

**데이터 처리 파이프라인**

- 데이터 소스에서 시작해 여러 중간 연산을 거쳐 최종 결과물을 생성하는 일련의 연산
- 특징 1 연결성 : 각 연산이 연결되어 하나의 체인처럼 동작하여, 복잡한 데이터 처리 로직을 간결하게 표현할 수 있습니다.
- 특징 2 지연 실행 : 중간 연산들은 최종 연산이 호출될 때까지 실제로 수행되지 않아, 필요하지 않은 계산을 피할 수 있습니다.
- 특징 3 : 병렬 처리 : 파이프라인은 내부적으로 데이터를 분할하고, 여러 스레드에서 동시에 처리할 수 있도록 설계되어 있어 멀티코어 환경에서 성능 최적화를 이룰 수 있습니다.

## 4.2 컬렉션과 스트림

**컬렉션**

- **정의:** 데이터를 저장하는 자료구조로, List, Set, Map 등과 같이 데이터를 메모리에 보관 및 관리합니다.
- **특징:**
    - **데이터 저장:** 모든 요소를 메모리에 미리 저장
    - **직접 처리:** 요소에 직접 인덱스나 반복자를 사용해 접근하며, 명시적(외부) 반복을 수행
    - **재사용:** 여러 번 반복하여 사용할 수 있음
    - **즉시 연산:** 요소가 즉시 계산되고 저장됨
        
        ```java
        List<String> names = new ArrayList<>();
        Iterator<Dish> iterator = menu.iterator();
        while(iterator.hasNext()) {
            Dish dish = iterator.next();
            names.add(dish.getName());
        }
        ```
        

**스트림**

- **정의:** 데이터를 저장하지 않고, **데이터의 흐름**(Pipeline)을 처리하는 데 초점을 맞춘다.
- **특징:**
    - **데이터 처리:** 컬렉션의 데이터를 하나씩 꺼내어 연산을 수행
    - **함수형 스타일:** 필터링, 매핑, 정렬 등 다양한 중간 연산을 조합해 처리
    - **내부 반복:** 스트림은 내부적으로 요소를 반복하며, 병렬 처리에 유리함
    - **일회성:** 한 번 소비하면 재사용할 수 없으므로, 반복 사용 시 새로운 스트림을 생성해야 함
    - **지연 연산(Lazy Evaluation):** 최종 연산이 호출될 때까지 연산을 수행하지 않음
    
    ```java
    List<String> names = menu.stream()
        .map(Dish::getName)
        .collect(toList());
    ```
    

**외부 반복**

- 개발자가 명시적으로 반복자를 사용하여 요소를 처리하는 방식입니다.
- 코드가 길어지고 반복 로직을 직접 관리해야 함

**내부 반복**

- 반복의 제어를 내부 함수나 라이브러리에 맡기는 방식
- 간결한 코드 작성과 최적화
- 외부 반복에 비해 사용이 제한적 일 수 있음

### 4.3 스트림 연산

**중간 연산**

- filter, map, limit, sorted, distinct
- 다른 스트림을 반환하여 파이프라인을 구성하며, 최종 연산 전까지 Lazy Evaluation으로 실행되지 않음. → 변환 규칙을 정의 하는 것

**최종 연산**

- 스트림을 소비하여 결과를 생성
- collect, count, forEach

### 4.3.1 일회성 흐름

- 일회성 : 한번 사용하면 다시 사용할 수 없다는 것
- 최종 연산이  호출되면 다시 사용할 수 없음
- 장점
    - 지연 평가, 내부 반복을 사용한 처리, 메모리 로드 X, 병렬 처리 등을 지원하는 목적으로 일회성 설계됨
        
        ```java
        import java.util.stream.Stream;
        
        public class StreamExample {
            public static void main(String[] args) {
                Stream<String> stream = Stream.of("A", "B", "C");
                stream.forEach(System.out::println);
                //  (IllegalStateException 발생)
                stream.forEach(System.out::println);
            }
        }
        ```
        

### 5. 스트림 연산

**filter(필터링)**

- Predicate를 통한 필터링
- filter메서드를 사용하여 조건에 맞는 요소만 선택
- 순서 중요 X

**distinct(필터링)**

- 중복 요소를 제거하여 고유한 스트림 생성

**takewhile(슬라이싱)**

- 주어진 조건이 참인 동안 요소를 가져오고, 조건이 거짓인 첫 요소에서 중단
- 순서 중요

**dropwhile(슬라이싱)**

- 조건이 참인 동안 요소를 버리고, 조건 위반 시점부터 모든 요소를 가져옴
- 순서 중요

**limit(축소)**

- 특정 개수만 선택하여 결과를 축소

**skip(건너뛰기)**

- 앞부분의 요소를 건너뛰고 나머지를 선택 limit과 반대

**map(매핑)**

- 특정 방식으로 변환하여 새로운 스트림을 생성
    - 원본 데이터를 변경하지 않고 새로운 데이터를 생성
    - 객체 리스트에서 특정 필드를 추출하거나 새로운 객체로 변환 가능
    - map(Persin::getName)

**flapmap(매핑)**

- 평탄화하여 하나의 리스트로 반환함.
