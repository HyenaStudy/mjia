# 스트림

## 1. 함수형 프로그래밍과 스트림

모든 프로그래밍 언어에서 함수형 프로그래밍은 **불변성**, **순수 함수**, **선언형**을 중요 키워드로 삼는다. 자바 8 역시 이를 준수하는 기능을 적용했는데 그것이 바로 **스트림(Stream)** 이다.

스트림은 우리말로 '시냇물, 흐름'이라는 뜻이다. 무엇을 흘러가게 할까 생각해봤는데 저번에 함수형 프로그래밍 기반 리팩토링 예제로 공부했었던 객체가 컨베이어벨트 위에 올려서 직접 움직이게 하고 검출기를 교체하는 구조가 떠올랐다. 각각의 키워드를 맞춰 정리해보면...

>1. 불변성 -> 작업이 끝났다고 기존 일련의 객체들의 상태가 변하지 않는다.
>2. 순수 함수 -> 객체들이 불변하므로 오로지 들어가는 객체에 따라서만 연산 결과가 결정된다.
>3. 선언형 -> 검출기의 동작 원리는 관심 없고, 그저 어떤 검출기를 가져다 놓을지만 고민한다.

각각에 대해 스트림과 관련하여 조금 더 구체적으로 알아보는 것으로 결정.

### 1) 불변성과 스트림

함수형 프로그래밍에서 초기화된 데이터가 연산에 쓰인 후에 그 데이터는 변하지 않는다.

```java
public class Main {
    public static void main(String[] args) {
        List<Person> people = List.of(
                new Person("김동준", 184, Gender.MALE),
                new Person("송아름", 200, Gender.FEMALE),
                new Person("채호연", 300, Gender.MALE),
                new Person("홍은영", 400, Gender.FEMALE),
                new Person("허예림", 500, Gender.FEMALE)
        );

        System.out.println("people1 == people2 : " + (people == people.stream().toList()));
    }
}
}
```

`people`과 `people` 스트림 호출 버전은 내부 요소들이 전부 동일하다. 초기 데이터인 `people`에 대해 별다른 가공이 없었기 때문\
그렇지만 객체가 동등한지 비교를 해보자

<img width="80%" alt="스크린샷 2025-02-24 오후 1 33 44" src="https://github.com/user-attachments/assets/9f75cfd2-7c91-45de-9a32-40e7dc6c8b5d" />

객체가 다르게 뜨는 이유는, 스트림 연산이 새로운 객체를 내뱉기 때문이다. 즉, 초기 데이터를 건드려서 기존 객체를 수정하지 않는다. 참고로 자바에서 객체의 `==`는 동일한 메모리 주소 참조 여부를 검증하는 데에 쓰인다. 결론은 초기 데이터의 **불변성**이 지켜진다.

### 2) 순수 함수와 스트림

데이터의 초기 불변성이 지켜지기 때문에, 연산 과정에서 데이터가 훼손될 우려가 없으므로 원하는 결과가 나오는 책임은 연산을 담당하는 검출기만 잘 동작하면 된다. 어찌됐든 함수형 프로그래밍 페러다임은 메소드 실행을 통해 외부의 값 변경에 대한 위험 시도를 없애는 것이 주요 목적이기 떄문이다. 앞서 말한 외부의 값 변경으로 인한 부작용을 **사이드 이펙트(Side Effect)** 혹은 부수 효과라고 부르는데, 사실 프로그래밍 관점에서 내가 동일한 입력값을 넣었음에도 매번 다른 값이 나오면 그것은 정상적인 연산은 아니다. 함수형 프로그래밍은 이를 절대적으로 중요시하므로 결국 외부 변수로 파생되는 사이드 이펙트를 없애려 하고, 이 사이드 이펙트가 없는 함수를 **순수 함수**라고 한다.

스트림은 동일한 입력값에 대해 동일한 연산을 수행하면 몇 번을 수행해도 동일한 결과가 나오도록 설계되어 있다. 즉, 스트림으로 수행되는 연산은 순수 함수 기반임을 알 수 있다.

### 3) 선언형과 스트림

기존의 필터는 명령형이었으면 이렇게 작성된다.

```java
List<Element> result;

for (Element e: List) {
    if (e.isMeetTheCreteria) result.add(e);
}
```

각각의 요소들에 대해 어떤 연산인지를 정의(선언)하고, 그 연산에 대해서 정의(명령)하는 과정이 필요했다.\
이것이 스트림으로 바뀌면 다음처럼 간결해진다.

```java
result.stream().filter(Element::isMeetTHeCreteria).toList();
```

각각의 요소들에 대해 어떤 연산이지를 정의(선언)하는 데에서 끝난다. 그 내부 동작은 개발자가 알 필요가 없어진다. 즉, **스트림은 선언형**이다.

## 2. 스트림 vs 컬렉션

얼핏 보면 컬렉션의 연산과 다를 바가 없지만, 실제로는 큰 차이가 있으면서도 컬렉션의 연산처럼 동작하게 하여 동일한 결과를 반환한다.

>- 저장소 없음 : 컬렉션은 일반적으로 물리적 데이터 집합인 반면, 스트림은 작업 파이프라인에 제공되는 논리적인 뷰
>- 본질적 기능 : 스트림에 대한 작업은 결과를 생성하지만 그 소스는 수정되지 않음. 예를 들어 스트림에 필터링을 호출하면 원래 컬렉션에서 스트림을 제거하는 대신 새 스트림을 반환
>- 지연 실행: 필터링, 매핑 등과 같은 많은 스트림 연산을 한꺼번에 묶어 터미널 연산을 사용하여 한 번에 실행. 이 기법은 연산을 처리하기 위한 최적화된 실행 전략 생성
>- 무제한 사이즈: 컬렉션과 다르게 무한 스트림이 존재. limit(n) 또는 findFirst()와 같은 단락 연산을 사용하면 무한 스트림에 대한 계산을 유한한 시간 내에 완료
>- 소모성: 스트림의 요소는 스트림의 수명 동안 한 번만 방문. 반복자와 마찬가지로 소스의 동일한 요소를 다시 방문하려면 새 스트림을 생성해야 함

### 1) 저장소 없음

## 3. 스트림 인터페이스
